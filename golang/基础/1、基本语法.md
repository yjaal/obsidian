```toc
```

这里内容是学习《Go 语言圣经》所做笔记


## 1. 基本说明

一般一个包下面所有的文件只允许存在一个 main 方法。

## 2. 申明


```go
// ch1/boiling.go
package main  
  
import "fmt"  
  
// 包一级范围声明，属于本包静态变量  
const boilingF = 212.0  
  
func main() {  
   test1()  
   test2()  
}  
  
func test1() {  
   var f = boilingF  
   var c = (f - 32) * 5 / 9  
   fmt.Printf("boiling point = %g°F or %g°C\n", f, c)  
}

```

```go
// ch1/demo1.go
package main  
  
import "fmt"  
  
func test2() {  
   fmt.Println("boiling %g", boilingF)  
}
```

其中常量 `boilingF` 是在包一级范围声明语句声明的，然后 `f` 和 `c` 两个变量是在 `test1` 函数内部声明的声明语句声明的。在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。


## 3. 变量

变量声明一般语法如下
```
var 变量名字   类型  =  表达式
```

其中 “_类型_” 或  “_= 表达式_”  两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。数值类型变量对应的零值是 0，布尔类型变量对应的零值是 `false`，字符串类型对应的零值是空字符串，接口或引用类型（包括 `slice`、指针、`map`、`chan` 和函数）变量对应的零值是 `nil`。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。因此在 Go 语言中不存在未初始化的变量。

如
```go
var s string
fmt.Println(s)
```

可以在一个声明中同时声明一组变量，也可以同时初始化多个变量

```go
var i, j int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化
```go
var f, err = os.Open(name) // os.Open returns a file and an error
```



### 3.1 简短变量声明

**在函数内部**，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。

```go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

请记住 “:=” 是一个变量声明语句，而 “=” 是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值，后者是将右边各个表达式的值赋值给左边对应位置的各个变量：
```go
i, j = j, i // 交换 i 和 j 的值
```

简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些已经在之前声明过了，那么后面就只是赋值行为了。在下面的代码中，第一个语句声明了 in 和 err 两个变量，第二个语句中只声明了一个 out 变量
```go
in, err := os.Open(infile)
out, err := os.Create(outfile)
```

简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：

```go
f, err := os.Open(infile)
f, err := os.Create(outfile)
```

### 3.2 指针

一个变量对应一个保存了变量对应类型值的内存空间。普通变量在声明语句创建时被绑定到一个变量名，比如叫 x 的变量。一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。

如果用“`var x int`”声明语句声明一个 x 变量，那么 `&x` 表达式（取 x 变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是 `*int `，指针被称之为“指向 `int` 类型的指针”。如果指针名字为 p，那么可以说“p 指针指向变量 x”，或者说“p 指针保存了 x 变量的内存地址”。同时 `*p ` 表达式对应 p 指针指向的变量的值。一般 `*p ` 表达式读取指针指向的变量的值，这里为 `int` 类型的值，同时因为 `*p ` 对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。

```go
x := 1
p := &x // p, of type *int, point to x
fmt.Println(*p) // "1"
*p = 2 // equivalent to x = 2
fmt.Println(x) // "2"
```

对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。

变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受`&`取地址操作。

任何类型的指针的零值都是 nil。如果 p 指向某个有效变量，那么 `p != nil` 测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是 nil 时才相等。

```go
var x, y int
fmt.Println(&x == &x, &x ==&y, &x == nil) // true, false, false
```

在 Go 语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用 f 函数时创建局部变量 v，在局部变量地址被返回之后依然有效，因为指针 p 依然引用这个变量。

```go
var p = f()

func f() *int {
	v := 1
	return &v
}
```

因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
```go
func incr(p *int) int {
	*p++ // 只是增加了p指向的变量的值，并不改变p指针
	return *p
}
v := 1
incr(&v) // side effect: v is now 2
fmt.Println(incr(&v)) // 3 and v is 3
```

这里只是为了演示，注意，不推荐这种方式。

指针是实现标准库中 flag 包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。为了说明这一点，在早些的 echo 版本中，就包含了两个可选的命令行参数：`-n` 用于忽略行尾的换行符，`-s sep` 用于指定分隔字符（默认是空格）。

```go
// ch2/echo4
package main  
  
import (  
   "flag"  
   "fmt"   "strings")  
  
var n = flag.Bool("n", false, "omit trailing newline")  
var sep = flag.String("s", " ", "separator")  
  
func main() {  
   flag.Parse()  
   fmt.Print(strings.Join(flag.Args(), *sep))  
   if !*n {
	  // 增加换行
      fmt.Println()  
   }}
```

调用 `flag.Bool` 函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是 false），最后是该标志参数对应的描述信息。如果用户在命令行输入了一个无效的标志参数，或者输入 ` -h ` 或 ` -help ` 参数，那么将打印所有标志参数的名字、默认值和描述信息。类似的，调用 `flag.String` 函数将创建一个对应字符串类型的标志参数变量，同样包含命令行标志参数对应的参数名、默认值、和描述信息。程序中的 ` sep ` 和 ` n ` 变量分别是指向对应命令行标志参数变量的指针，因此必须用 `*sep ` 和 `*n ` 形式的指针语法间接引用它们。

当程序运行时，必须在使用标志参数对应的变量之前先调用 flag. Parse 函数，用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普通命令行参数可以通过调用 `flag.Args()` 函数来访问，返回值对应一个字符串类型的 `slice`。如果在 `flag.Parse` 函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用 `os.Exit(2)` 终止程序。

执行
```shell
$ go build gopl.io/ch2/echo4
$ ./echo4 a bc def
a bc def

$ ./echo4 -s / a bc def
a/bc/def

$ ./echo4 -n a bc def
a bc def
$ ./echo4 -help
Usage of ./echo4:
-n omit trailing newline
-s string separator (default " ")
```


### 3.3 new 函数
另一个创建变量的方法是调用内建的 `new` 函数。表达式 `new(T)` 将创建一个 T 类型的匿名变量，初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 `*T `。
```go
p := new(int) // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2 // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

new 函数类似是一种语法糖，而不是一个新的基础概念。每次调用 new 函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```
当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是 0，例如 `struct{}` 和 `[0]int`，有可能有相同的地址（依赖具体的语言实现）。new 函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。

由于 new 只是一个预定义的函数，它并不是一个关键字，因此我们可以将 new 名字重新定义为别的类型。例如下面的例子：

```go
func delta(old, new int) int { return new - old }
```

由于 new 被定义为 int 类型的变量名，因此在 delta 函数内部是无法使用内置的 new 函数的。


### 3.4 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

```go
var global *int

func f() {
	var x int
	x = 1
	global = &x
}
func g() {
	y := new(int)
	*y = 1
}
```

f 函数里的 x 变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的；用 Go 语言的术语说，这个 x 局部变量从函数 f 中逃逸了。相反，当 g 函数返回时，变量 `*y` 将是不可达的，也就是说可以马上被回收的。因此，`*y` 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 `*y` 的存储空间（译注：也可以选择在堆上分配，然后由 Go 语言的 GC 回收这个变量的内存空间），虽然这里用的是 new 方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

## 4. 赋值

数值变量也可以支持 `++` 递增和 `--` 递减语句（译注：自增和自减是语句，而不是表达式，因此 `x = i++` 之类的表达式是错误的）：

### 4.1 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：

```go
x, y = y, x
a[i], a[j] = a[j], a[i]
```

计算两个整数值的的最大公约数（GCD）
```go
func gcd(x, y int) int{
	for y != 0 {
		x, y = y, x % y
	}
	return x
}
```

计算斐波纳契数列（Fibonacci）的第 N 个数：
```go
func fib(n int) int {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		x, y = y, x + y
	}
	return x
}
```

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。
```go
f, err = os.Open("foo.txt")
```

通常，这类函数会用额外的返回值来表达某种错误类型，例如 `os.Open` 是用额外的返回值返回一个 `error` 类型的错误，还有一些是用来返回布尔值，通常被称为 ok。在稍后我们将看到的三个操作都是类似的用法。如果 map 查找、类型断言或通道接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功：

```go
v, ok = m[key] // map lookup
v, ok = x.(T) // type assertion
v, ok = <-ch // channel receive
```

map 查找、类型断言或通道接收出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map 查找失败时会返回零值，类型断言失败时会发生运行时 `panic` 异常，通道接收失败时会返回零值（阻塞不算是失败）。例如下面的例子：

```go
v = m[key] // map查找，失败时返回零值
v = x.(T) // type断言，失败时panic异常
v = <-ch // 管道接收，失败时返回零值（阻塞不算是失败）
  
_, ok = m[key] // map返回2个值
_, ok = mm[""], false // map返回1个值
_ = mm[""] // map返回1个值
```

和变量声明一样，我们可以用下划线空白标识符 `_` 来丢弃不需要的值。

```go
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T) // 只检测类型，忽略具体值
```

### 4.2 可赋值性

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：
```go
medals := []string{"gold", "silver", "bronze"}
```

这里其实就是一个数组赋值。

## 5. 类型

在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。例如，一个 `int` 类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份；一个 ` float64 ` 类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度；一个字符串可以用来表示一个密码或者一个颜色的名称。

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

```go
type 类型名字 底层类型
```

```go
import "fmt"

type Celsius float64 // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
	AbsoluteZeroC Celsius = -273.15 // 绝对零度
	FreezingC Celsius = 0 // 结冰点温度
	BoilingC Celsius = 100 // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

在这个包声明了两种类型：`Celsius` 和 `Fahrenheit` 分别对应不同的温度单位。它们虽然有着相同的底层类型 `float64`，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似 `Celsius(t)` 或 `Fahrenheit(t)` 形式的显式转型操作才能将 `float64` 转为对应的类型。`Celsius (t)` 和 `Fahrenheit(t)` 是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，`CToF` 和 `FToC` 两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。

要注意，不同类型的变量之间是不能进行比较的。

## 6. 包和文件

一个包的源代码保存在一个或多个以 `.go` 为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包 `gopl.io/ch1/helloworld` 对应的目录路径是 `$GOPATH/src/gopl.io/ch1/helloworld`。

每个包都对应一个独立的名字空间。例如，在 `image` 包中的 `Decode` 函数和在 `unicode/utf16` 包中的 `Decode` 函数是不同的。要在外部引用该函数，必须显式使用 `image.Decode` 或 `utf16.Decode` 形式访问。

### 6.1 导入包

在 Go 语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"`gopl. io/ch2/tempconv"` 的字符串对应包的导入路径。导入时如

```go
import (
	"fmt"
	"gopl.io/ch2/tempconv"
)
```



## 7. 基础数据类型

### 7.1 整形

Go 语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

Go 语言同时提供了有符号和无符号类型的整数运算。这里有 `int8、int16、int32` 和 `int64` 四种截然不同大小的有符号整数类型，分别对应 `8、16、32、64bit` 大小的有符号整数，与此对应的是 `uint8、uint16、uint32` 和 `uint64` 四种无符号整数类型。

这里还有两种一般对应特定 CPU 平台机器字大小的有符号和无符号整数 `int` 和 `uint`；其中 `int` 是应用最广泛的数值类型。这两种类型都有同样的大小，32 或 64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

最后，还有一种无符号的整数类型 `uintptr`，没有指定具体的 `bit` 大小但是足以容纳指针。`uintptr` 类型只有在底层编程时才需要，特别是 Go 语言和 C 语言函数库或操作系统接口相交互的地方。

Go 语言还提供了以下的 bit 位操作运算符，前面 4 个操作运算符并不区分是有符号还是无符号数：

```
& 位运算 AND
| 位运算 OR
^ 位运算 XOR
&^ 位清空（AND NOT）就是按位置零
<< 左移
>> 右移
```


### 7.2 浮点数

Go 语言提供了两种精度的浮点数，`float32` 和 `float64`。浮点数的范围极限值可以在 `math` 包找到。常量 ` math. MaxFloat32 ` 表示 ` float32 ` 能表示的最大数值。用 ` Printf ` 函数的 ` %g ` 参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用 ` %e `（带指数）或 ` %f ` 的形式打印可能更合适。

`math` 包中除了提供大量常用的数学函数外，还提供了 `IEEE754` 浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有 `NaN` 非数，一般用于表示无效的除法操作结果 ` 0/0 ` 或 ` Sqrt (-1) `.

```go
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

### 7.3 复数

Go 语言提供了两种精度的复数类型：`complex64` 和 `complex128`，分别对应 ` float32` 和 `float64` 两种浮点数精度。内置的 `complex` 函数用于构建复数，内建的 `real` 和 `imag` 函数分别返回复数的实部和虚部：

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y) // "(-5+10i)"
fmt.Println(real(x*y)) // "-5"
fmt.Println(imag(x*y)) // "10"
```

### 7.4 布尔型
一个布尔类型的值只有两种：`true ` 和 ` false`。布尔值并不会隐式转换为数字值 0 或 1，反之亦然。

### 7.5 字符串

一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括 `byte` 值 0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用 `UTF8` 编码的 `Unicode 码点（rune）` 序列

内置的 len 函数可以返回一个字符串中的字节数目（不是 `rune` 字符数目），索引操作 ` s[i] ` 返回第 ` i ` 个字节的字节值，` i ` 必须满足 ` 0 ≤ i< len (s) ` 条件约束。
```go
s := "hello, world"
fmt.Println(len(s)) // 12
fmt.Println(s[0], s[7]) // 104, 119
```


#### 7.5.1 字符串面值

字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可。在一个双引号包含的字符串面值中，可以用以反斜杠 `\` 开头的转义序列插入任意的数据。

一个原生的字符串面值形式是 \`...\`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写 \` 字符的，可以用八进制或十六进制转义或+"\`"连接字符串常量完成）。

#### 7.5.2 字符串和 Byte 切片

标准库中有四个包对字符串处理尤为重要：`bytes、strings、strconv` 和 `unicode` 包。`strings` 包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

`bytes` 包也提供了很多类似功能的函数，但是只是针对和字符串有着相同结构的 `[]byte ` 类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用 `bytes.Buffer ` 类型将会更有效。

`strconv` 包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。

`unicode` 包提供了 `IsDigit、IsLetter、IsUpper` 和 ` IsLower` 等类似功能，它们用于给字符分类。每个函数有一个单一的 `rune` 类型的参数，然后返回一个布尔值。而像 `ToUpper` 和 `ToLower` 之类的转换函数将用于 `rune` 字符的大小写转换。所有的这些函数都是遵循 `Unicode` 标准定义的字母、数字等分类规范。`strings` 包也有类似的函数，它们是 `ToUpper` 和 `ToLower`，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。

**一个字符串是包含只读字节的数组，一旦创建，是不可变的**。相比之下，一个字节切片的元素则可以自由地修改。字符串和字节切片之间可以相互转换：

```go
s := "abc" 
b := []byte(s)
s2 := string(b)
```

从概念上讲，一个 `[]byte(s)` 转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量 b 被修改的情况下，原始的 s 字符串也不会改变。将一个字节 `slice` 转换到字符串的 `string(b)` 操作则是构造一个字符串拷贝，以确保 s2 字符串是只读的。

为了避免转换中不必要的内存分配，bytes 包和 strings 同时提供了许多实用函数。下面是 `strings` 包中的六个函数：
```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```

`bytes` 包中也对应的六个函数：
```go
func Contains(b, subslice []byte) bool
func Count(s, sep []byte) int
func Fields(s []byte) [][]byte
func HasPrefix(s, prefix []byte) bool
func Index(s, sep []byte) int
func Join(s [][]byte, sep []byte) []byte
```

它们之间唯一的区别是字符串类型参数被替换成了字节 slice 类型的参数。

`bytes` 包还提供了 `Buffer` 类型用于字节 slice 的缓存。一个 `Buffer` 开始是空的，但是随着 `string、byte 或[]byte` 等类型数据的写入可以动态增长，一个 `bytes. Buffer` 变量并不需要初始化，因为零值也是有效的：

```go
// intsToString is like fmt.Sprint(values) but adds commas.
func intsToString(values []int) string {
	var buf bytes.Buffer
	buf.WriteByte('[')
	for i, v := range values {
		if i > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%d", v)
	}
	buf.WriteByte(']')
	return buf.String()
}

func main() {
	fmt.Println(intsToString([]int{1, 2, 3})) // "[1, 2, 3]"
}
```

## 8. 常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：`boolean、string 或数字`。

```go
const pi = 3.14159
```

和变量一样，可以批量声明多个常量
```go
const (
	e = 2.71828182845904523536028747135266249775724709369995957496696763
	pi = 3.14159265358979323846264338327950288419716939937510582097494459
)
```

所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。

还可以更简略的声明
```go
const (
	a = 1
	b
	c = 2
	d
)
```
当然一般也不推荐这样使用，但是这在 iota 常量生成器语法比较实用。

### 8.1 iota 常量生成器

常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。

下面是来自 time 包的例子，它首先定义了一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始。在其它编程语言中，这种类型一般被称为枚举类型。

```go
type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednestday
	Thursday
	Friday
	Saturday
)
```

我们也可以在复杂的常量表达式中使用 iota，下面是来自 net 包的例子，用于给一个无符号整数的最低 `5bit` 的每个 `bit` 指定一个名字：

```go
type Flags uint  
  
const (  
   FlagUp Flags = 1 << iota   // 2^0
   FlagBroadcast  // 2^1
   FlagLoopback   // 2^2
   FlagPointToPoint   // 2^3
   FlagMulticast)  // 2^4
```

随着 iota 的递增，每个常量对应表达式 `1 << iota`，是连续的 2 的幂，分别对应一个 bit 位置。

下面是一个更复杂的例子，每个常量都是 1024 的幂：
```go
const (
	_ = 1 << (10 * iota)
	KiB // 1024^1
	MiB // 1024^2
	GiB // 1024^3
	TiB
	PiB
	EiB
	ZiB
	YiB
)
```
不过 iota 常量生成规则也有其局限性。例如，它并不能用于产生 1000 的幂（KB、MB 等），因为 Go 语言并没有计算幂的运算符。

### 8.2 无类型常量

Go 语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 `int` 或 `float64`，或者是类似 `time.Duration` 这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有 `256bit` 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的 `ZiB` 和 `YiB` 的值已经超出任何 Go 语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：` YiB/ZiB ` 是在编译期计算出来的，并且结果常量是 1024，是 Go 语言 ` int ` 变量能有效表示的）：

```go
fmt.Println(YiB/ZiB) // 1024
```

另一个例子，`math.Pi` 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

只有常量可以是无类型的。这里通过赋值给了相关变量，之后变量如 `x,y,z` 则都是有确定类型的，如果相互需要转换，那么需要强制转换。

对于常量面值，不同的写法可能会对应不同的类型。例如 `0、0.0、0i和 \u0000 ` 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，`true` 和 `false` 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。

注意有一点不同：无类型整数常量转换为 `int`，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的 `float64` 和 `complex128`。如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此 Go 语言不存在整型类似的不确定内存大小的浮点数和复数类型。

如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型，像下面例子这样：

```go
var i = int8(0)
var i int8 = 0
```


























































