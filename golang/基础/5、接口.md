
```toc

```


## 接口是合约

在 Go 语言中存在着一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。

在本书中，我们一直使用两个相似的函数来进行字符串的格式化：`fmt.Printf`，它会把结果写到标准输出，和 `fmt.Sprintf`，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数 `fmt.Fprintf` 来进行封装。`fmt.Fprintf` 这个函数对它的计算结果会被怎么使用是完全不知道的。

```go
package fmt

func Fprintf (w io.Writer, format string, args ... interface{}) (int, error)
func Printf (format string, args ... interface{}) (int, error) {
    return Fprintf (os.Stdout, format, args...)
}
func Sprintf (format string, args ... interface{}) string {
    var buf bytes.Buffer
    Fprintf (&buf, format, args...)
    return buf.String ()
}
```
`Fprintf` 的前缀 `F` 表示文件（`File`）也表明格式化输出结果应该被写入第一个参数提供的文件中。在 `Printf` 函数中的第一个参数 `os.Stdout` 是 `*os.File` 类型；在 `Sprintf` 函数中的第一个参数 `&buf` 是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。

即使 `Fprintf` 函数中的第一个参数也不是一个文件类型。它是 `io.Writer` 类型，这是一个接口类型定义如下：

```go
package io

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    // Write writes len (p) bytes from p to the underlying data stream.
    // It returns the number of bytes written from p (0 <= n <= len (p))
    // and any error encountered that caused the write to stop early.
    // Write must return a non-nil error if it returns n < len (p).
    // Write must not modify the slice data, even temporarily.
    //
    // Implementations must not retain p.
    Write (p []byte) (n int, err error)
}
```

`io.Writer` 类型定义了函数 `Fprintf` 和这个函数调用者之间的**约定**。一方面这个约定需要调用者提供具体类型的值就像 `*os.File` 和 `*bytes.Buffer`，这些类型都有一个特定签名和行为的 `Write` 的函数。另一方面这个约定保证了 `Fprintf` 接受任何满足 `io.Writer` 接口的值都可以工作。`Fprintf` 函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用 `Write` 函数的值。

因为 `fmt.Fprintf` 函数没有对具体操作的值做任何假设，而是仅仅通过 `io.Writer` 接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足 `io.Writer` 接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP 里氏替换）。这是一个面向对象的特征。

## 接口类型定义

`io.Writer` 类型是用得最广泛的接口之一，因为它提供了所有类型的写入 `bytes` 的抽象，包括文件类型，内存缓冲区，网络链接，`HTTP` 客户端，压缩工具，哈希等等。`io` 包中定义了很多其它有用的接口类型。`Reader` 可以代表任意可以读取 `bytes` 的类型，`Closer` 可以是任意可以关闭的值，例如一个文件或是网络链接。

```go
package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
```

再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：

```go
type ReadWriter interface {
    Reader
    Writer
}
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明 `io.ReadWriter` 接口。

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

或者甚至使用一种混合的风格：

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}
```

上面 3 种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。

## 实现接口的条件

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。例如，`*os.File` 类型实现了 `io.Reader，Writer，Closer，和 ReadWriter 接口`。`*bytes. Buffer ` 实现了 `Reader，Writer，和 ReadWriter` 这些接口，但是它没有实现 `Closer` 接口因为它不具有 `Close` 方法。Go 的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，`*bytes.Buffer ` 是 `io.Writer`；`*os.Files ` 是 `io.ReadWriter`。

接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：

```go
var w io.Writer
w = os.Stdout           // OK: *os.File has Write method
w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method
w = time.Second         // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method
```

这个规则甚至适用于等式右边本身也是一个接口类型

```go
w = rwc                 // OK: io.ReadWriteCloser has Write method
rwc = w                 // compile error: io.Writer lacks Close method
```

因为 `ReadWriter` 和 `ReadWriteCloser` 包含有 `Writer` 的方法，所以任何实现了 `ReadWriter` 和 `ReadWriteCloser` 的类型必定也实现了 `Writer` 接口。也就是说想要把某个接口 `A` 赋值给某个接口 `B`，那么 `A` 必须实现 `B` 中定义的方法。

对于每一个命名过的具体类型 `T`；它的一些方法的接收者是类型 `T` 本身然而另一些则是一个 `*T ` 的指针。还记得在 `T` 类型的参数上调用一个 `*T ` 的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。但这仅仅是一个语法糖：**`T` 类型的值不拥有所有 `*T ` 指针的方法，这样它就可能只实现了更少的接口。**

举个例子可能会更清晰一点。在之前的章节中，`IntSet` 类型的 `String` 方法的接收者是一个指针类型，所以我们不能在一个不能寻址的 `IntSet` 值上调用这个方法：

```go
type IntSet struct { /* ... */ }
func (*IntSet) String() string
var _ = IntSet{}.String() // compile error: String requires *IntSet receiver
```

但是我们可以在一个 `IntSet` 变量上调用这个方法：

```go
var s IntSet
var _ = s.String() // OK: s is a variable and &s has a String method
```

然而，由于只有 `*IntSet` 类型有 String 方法，所以也只有 `*IntSet` 类型实现了 `fmt.Stringer` 接口：

```go
var _ fmt.Stringer = &s // OK
var _ fmt.Stringer = s  // compile error: IntSet lacks String method
```

后面章节会展示一个打印出任意值的所有方法的程序，以及展示每个类型的方法和具体类型和接口之间的关系的程序。

就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到，也只有接口类型暴露出来的方法可以被调用到。

一个有更多方法的接口类型，比如 `io.ReadWriter`，和少一些方法的接口类型例如 `io.Reader`，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。那么关于 `interface{}` 类型，它没有任何方法，请讲出哪些具体的类型实现了它？

这看上去好像没有用，但实际上 `interface{}` 被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。

```go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]int{"one": 1}
any = new(bytes.Buffer)
```

尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像 `fmt.Println` 或者之前章节中的 `Errorf` 函数接受任何类型的参数。

对于创建的一个 `interface{}` 值持有一个 ` boolean，float，string，map，pointer`，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为 `interface{}` 没有任何方法。我们会在后面章节中学到一种用类型断言来获取 `interface{} ` 中值的方法。

因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个 `*bytes.Buffer` 的值实现了 `io.Writer` 接口类型:

```go
// *bytes.Buffer must satisfy io.Writer
var w io.Writer = new(bytes.Buffer)
```

因为任意 `*bytes.Buffer` 的值，甚至包括 `nil` 通过 ` (*bytes. Buffer)(nil) ` 进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量 `w`，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：

```go
// 断言推荐使用此方式
// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)
```

非空的接口类型比如 `io.Writer` 经常被指针类型实现，尤其当一个或多个接口方法像 `Write` 方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。


## flag. Value 接口

我们会学到另一个标准的接口类型 `flag.Value` 是怎么帮助命令行标记定义新的符号的（其实就是一种解析命令行参数的接口）。思考下面这个会休眠特定时间的程序：

```go
var period = flag.Duration("period", 1*time.Second, "sleep period")

func main() {
    flag.Parse()
    fmt.Printf("Sleeping for %v...", *period)
    time.Sleep(*period)
    fmt.Println()
}
```

正常输出

```shell
$ go build gopl.io/ch7/sleep
$ ./sleep
Sleeping for 1s...
```
默认休眠周期是一秒，但是可以通过 `-period` 这个命令行标记来控制。`flag.Duration` 函数创建一个 `time.Duration` 类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和 `String` 方法相同的符号排版形式。这种对称设计使得用户交互良好。

```shell
$ ./sleep -period 50ms
Sleeping for 50ms...
$ ./sleep -period 1.5h
Sleeping for 1h30m0s...
$ ./sleep -period "1 day"
invalid value "1 day" for flag -period: time: invalid duration 1 day
```

我们为我们自己的数据类型定义新的标记符号是简单容易的。我们只需要定义一个实现 `flag. Value` 接口的类型，如下：

```go
package flag

// Value is the interface to the value stored in a flag.
type Value interface {
	// String方法格式化标记的值用在命令行帮助消息中；
	// 这样每一个flag.Value也是一个fmt.Stringer。
    String() string
    // Set方法解析它的字符串参数并且更新标记变量的值。
    Set(string) error
}
```

下面自定义一个 `Value` 接口
```go
// tempconv.go
package tempconv  
  
import (  
   "flag"  
   "fmt")  
  
type Celsius float64  
type Fahrenheit float64  
  
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9.0/5.0 + 32.0) }  
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32.0) * 5.0 / 9.0) }  
  
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }  
  
type celsiusFlag struct{ Celsius }  
  
func (f *celsiusFlag) Set(s string) error {  
   var unit string  
   var value float64  
   fmt.Sscanf(s, "%f%s", &value, &unit) // no error check needed  
   switch unit {  
   case "C", "°C":  
      f.Celsius = Celsius(value)  
      return nil  
   case "F", "°F":  
      f.Celsius = FToC(Fahrenheit(value))  
      return nil  
   }  
   return fmt.Errorf("invalid temperature %q", s)  
}  
  
// CelsiusFlag defines a Celsius flag with the specified name,// default value, and usage, and returns the address of the flag variable.  
// The flag argument must have a quantity and a unit, e.g., "100C".  
func CelsiusFlag(name string, value Celsius, usage string) *Celsius {  
   f := celsiusFlag{value}  
   flag.CommandLine.Var(&f, name, usage)  
   return &f.Celsius  
}
```

```go
// demo.go
package tempconv  
  
import (  
   "flag"  
   "fmt")  
  
var temp = CelsiusFlag("temp", 20.0, "the temperature")  
  
func main() {  
   // 用于转换请求餐素  
   flag.Parse()  
   fmt.Println(*temp)  
}
```

输出

```shell
$ go build gopl.io/ch7/tempflag
$ ./tempflag
20°C
$ ./tempflag -temp -18C
-18°C
$ ./tempflag -temp 212°F
100°C
$ ./tempflag -temp 273.15K
invalid value "273.15K" for flag -temp: invalid temperature "273.15K"
Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
$ ./tempflag -help
Usage of ./tempflag:
  -temp value
        the temperature (default 20°C)
```


## 接口值

接口值由两个部分组成，一个具体的类型和那个类型的值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。

下面 4 个语句中，变量 w 得到了 3 个不同的值。（开始和最后的值是相同的）

```go
// 值为nil
var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
// 值为nil
w = nil
```

第一个语句定义了变量 `w`: 在 Go 语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是 `nil`

![](./img/5.01.png)

一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用 `w==nil 或者 w!=nil` 来判断接口值是否为空。调用一个空接口值上的任意方法都会产生 `panic`:

```go
w.Write([]byte("hello")) // panic: nil pointer dereference
```

第二个语句将一个 `*os.File` 类型的值赋给变量 w: 这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用 `io.Writer(os. Stdout)` 是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为 `*os.File` 指针的类型描述符，它的动态值持有 `os.Stdout` 的拷贝；这是一个代表处理标准输出的 `os.File` 类型变量的指针

![](./img/5.02.png)

调用一个包含 `*os.File` 类型指针的接口值的 Write 方法，使得 `(*os.File).Write` 方法被调用。这个调用输出 `“hello”`。

```go
w.Write([]byte("hello")) // "hello"
```

通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法 `Write` 上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，`os.Stdout`。效果和下面这个直接调用一样：

```go
os.Stdout.Write([]byte("hello")) // "hello"
```

第三个语句给接口值赋了一个 `*bytes.Buffer` 类型的值

```
w = new(bytes.Buffer)
```

现在动态类型是 `*bytes. Buffer` 并且动态值是一个指向新分配的缓冲区的指针

![](./img/5.03.png)

最后一个语句重置将它所有的部分都设为 `nil` 值，把变量 `w` 恢复到和它之前定义时相同的状态。

**比较**
接口值可以使用 `==和!＝` 来进行比较。两个接口值相等仅当它们都是 `nil` 值，或者它们的动态类型相同并且动态值也根据这个动态类型的 `==` 操作相等。因为接口值是可比较的，所以它们可以用在 `map` 的键或者作为 `switch` 语句的操作数。

然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且 `panic`:

```go
var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // panic: comparing uncomparable type []int
```


### 警告：一个包含 nil 指针的接口不是 nil 接口

直观理解就是接口包含类型和接口值，只有接口的类型和值都为 `nil` 时，接口才为 `nil`，如果只是值为 `nil`，而接口类型不为 `nil`，那么接口就不为 `nil`。看下面的例子

```go
const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.
func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte("done!\n")) // panic
    }
}
```

我们可能会预计当把变量 `debug` 设置为 `false` 时可以禁止对输出的收集，但是实际上在 `out. Write` 方法调用时程序发生了 `panic`。原因就在这里

```go
buf = new(bytes.Buffer)
```

这在 `debug` 为 `true` 时执行后 `buf` 不为 `nil`，但是 `debug` 为 `false` 后，`buf` 被赋值为 `nil`。但是要注意，这里是将 `buf` 的值赋值为了 `nil`，但是其类型还是一个指针类型，`*bytes.Buffer` 本身不是一个具体类型，而是指向 `nil` 的指针。所以这并不是一个 `nil` 接口（因为有些接口是支持在 `nil` 上使用的）。当我们向一个 `nil` 调用 `Write` 方法时就会发生异常。正确的做法是将 `buf` 定义为 `io.Writer`，因为 `io.Writer` 是一个具体类型，而不是一个指针，于是 `buf` 成了一个 `nil` 接口，避免了异常。



## sort. Interface 接口




















