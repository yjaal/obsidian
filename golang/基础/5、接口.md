
```toc

```


## 接口是合约

在 Go 语言中存在着一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。

在本书中，我们一直使用两个相似的函数来进行字符串的格式化：`fmt.Printf`，它会把结果写到标准输出，和 `fmt.Sprintf`，它会把结果以字符串的形式返回。得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数 `fmt.Fprintf` 来进行封装。`fmt.Fprintf` 这个函数对它的计算结果会被怎么使用是完全不知道的。

```go
package fmt

func Fprintf (w io.Writer, format string, args ... interface{}) (int, error)
func Printf (format string, args ... interface{}) (int, error) {
    return Fprintf (os.Stdout, format, args...)
}
func Sprintf (format string, args ... interface{}) string {
    var buf bytes.Buffer
    Fprintf (&buf, format, args...)
    return buf.String ()
}
```
`Fprintf` 的前缀 `F` 表示文件（`File`）也表明格式化输出结果应该被写入第一个参数提供的文件中。在 `Printf` 函数中的第一个参数 `os.Stdout` 是 `*os.File` 类型；在 `Sprintf` 函数中的第一个参数 `&buf` 是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。

即使 `Fprintf` 函数中的第一个参数也不是一个文件类型。它是 `io.Writer` 类型，这是一个接口类型定义如下：

```go
package io

// Writer is the interface that wraps the basic Write method.
type Writer interface {
    // Write writes len (p) bytes from p to the underlying data stream.
    // It returns the number of bytes written from p (0 <= n <= len (p))
    // and any error encountered that caused the write to stop early.
    // Write must return a non-nil error if it returns n < len (p).
    // Write must not modify the slice data, even temporarily.
    //
    // Implementations must not retain p.
    Write (p []byte) (n int, err error)
}
```

`io.Writer` 类型定义了函数 `Fprintf` 和这个函数调用者之间的**约定**。一方面这个约定需要调用者提供具体类型的值就像 `*os.File` 和 `*bytes.Buffer`，这些类型都有一个特定签名和行为的 `Write` 的函数。另一方面这个约定保证了 `Fprintf` 接受任何满足 `io.Writer` 接口的值都可以工作。`Fprintf` 函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用 `Write` 函数的值。

因为 `fmt.Fprintf` 函数没有对具体操作的值做任何假设，而是仅仅通过 `io.Writer` 接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足 `io.Writer` 接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP 里氏替换）。这是一个面向对象的特征。

## 接口类型定义

`io.Writer` 类型是用得最广泛的接口之一，因为它提供了所有类型的写入 `bytes` 的抽象，包括文件类型，内存缓冲区，网络链接，`HTTP` 客户端，压缩工具，哈希等等。`io` 包中定义了很多其它有用的接口类型。`Reader` 可以代表任意可以读取 `bytes` 的类型，`Closer` 可以是任意可以关闭的值，例如一个文件或是网络链接。

```go
package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
```

再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：

```go
type ReadWriter interface {
    Reader
    Writer
}
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明 `io.ReadWriter` 接口。

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

或者甚至使用一种混合的风格：

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}
```

上面 3 种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。











