
```toc
```

参考：
```
https://www.cnblogs.com/fudashi/p/7506877.html
https://www.cnblogs.com/fudashi/p/7508272.html
```

## 表连接算法

Nested Loop Join（NLJ）算法：

首先介绍一种基础算法: NLJ，嵌套循环算法。循环外层是驱动表，循坏内层是被驱动表。驱动表会驱动被驱动表进行连接操作。首先驱动表找到第一条记录，然后从头扫描被驱动表，逐一查找与驱动表第一条记录匹配的记录然后连接起来形成结果表中的一条记。被驱动表查找完后，再从驱动表中取出第二个记录，然后从头扫描被驱动表，逐一查找与驱动表第二条记录匹配的记录，连接起来形成结果表中的一条记录。重复上述操作，直到驱动表的全部记录都处理完毕为止。这就是嵌套循环连接算法的基本思想，伪代码如下。

```
foreach row1 from t1
        foreach row2 from t2
            if row2 match row1 //row2与row1匹配，满足连接条件
                join row1 and row2 into result //连接row1和row2加入结果集
```

首先加载 t 1，然后从 t 1 中取出第一条记录，之后加载 t 2 表，与 t 2 表中的记录逐个匹配，连接匹配的记录。

Block Nested Loop Join (BNLJ)算法：

再介绍一种高级算法：BNLJ，块嵌套循环算法，可以看作对 NLJ 的优化。大致思想就是建立一个缓存区，一次从驱动表中取多条记录，然后扫描被驱动表，被驱动表的每一条记录都尝试与缓冲区中的多条记录匹配，如果匹配则连接并加入结果集。缓冲区越大，驱动表一次取出的记录就越多。这个算法的优化思路就是减少内循环的次数从而提高表连接效率。

## 影响性能的因素

1. 内循环的次数：现在考虑这么一个场景，当 t 1 有 100 条记录，t 2 有 10000 条记录。那么，t 1 驱动 t 2 与 t 2 驱动 t 1，他们之间在效率上孰优孰劣？如果是单纯的分析指令执行次数，他们都是 100*10000, 但是考虑到加载表的次数呢。首先分析 t 1 驱动 t 2，t 1 表加载 1 次，t 2 表需要加载 100 次。然后分析 t 2 驱动 t 1，t 2 表首先加载 1 次，但是 t 1 表要加载 10000 次。所以，t 1 驱动 t 2 的效率要优于 t 2 驱动 t 1 的效率。由此得出，小表驱动大表能够减少内循环的次数从而提高连接效率。
另外，如果使用 Block Nested Loop Join 算法的话，通过扩大一次缓存区的大小也能减小内循环的次数。由此又可得，设置合理的缓冲区大小能够提高连接效率

2. 快速匹配：扫描被驱动表寻找合适的记录可以看做一个查询操作，如何提高查询的效率呢？建索引啊！由此还可得出，在被驱动表建立索引能够提高连接效率

3. 排序：假设 t 1 表驱动 t 2 表进行连接操作，连接条件是 t 1. Id=t 2. Id，而且要求查询结果对 id 排序。现在有两种选择，方式一[... ORDER BY t 1. Id]，方式二[... ORDER BY t 2. Id]。如果我们使用方式一的话，可以先对 t 1 进行排序然后执行表连接算法，如果我们使用方式二的话，只能在执行表连接算法后，对结果集进行排序（Using temporary），效率自然低下。由此最后可得出，优先选择驱动表的属性进行排序能够提高连接效率。

**最后其实 mysql 会自己进行优化，但是我们自己也可以遵循"小表驱动大表+索引"的原则**

想要从快速匹配的角度优化 JOIN，首先就是找出谁是驱动表，谁是被驱动表，然后在被驱动表上建立索引即可。（正常来说是小表驱动大表）


