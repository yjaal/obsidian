
```toc
```


## 概述

不仅会在选择题中出现，而且在案例分析也必然出现一道大题。选择题一般占 5-6 分

## 数据库基本概念

### 数据库系统结构

![](../../001.jpeg)

- 内模式：其实就是一些底层的存储文件等等
- 模式：或叫概念模式，其实就是创建的一些表
- 外模式：其实就是一些 view，我们可以自己创建 view，而一般通过查询语句也会产生一个虚拟 view
- 外模式/概念模式映像：其实就是一个关联，比如我们查询有时候会涉及多张表联合查询，有些表字段的变更有时候不会对这个映像产生影响
- 概念模式/内模式映像：这个其实就是想管的表和具体的底层存储引擎的一个映射，我们可以变更底层存储引擎，但是用户关注的表其实没有影响。

*逻辑独立性*
当模式改变时（如增加新的关系，新的属性等），由数据库管理员对各个外模式/模式的映像做响应的改变，可以使得外模式保持不变。应用程序时依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。

*物理独立性*
当数据库的存储结构改变了，由数据库管理员对模式/内模式映像做出相应的改变，可以使模式保持不变，从而应用程序也不需要改变，保证了数据与程序的物理独立性。

### 数据库设计步骤

![](../../002.jpeg)

这里要注意每一步的产出：
- 需求分析产出：数据流图（其实就是一些数据的流向，比如这个数据用于哪里哪个场景），数据字典（也就是字段说明），需求说明书
- 概念结构设计产出：ER 模型图。这里又有整体 ER 图，区域 ER 图，整体 ER 图可能比较大，需要对一些区域 ER 图合并简化。
- 逻辑结构设计产出：关系模式。也就是转换为相关对象，或者说用户视图。
- 物理设计：比如使单点存储，还是分布式存储

![](../../003.jpeg)


### 数据模型

主要有两类：概念数据模型（实体-联系模型 Entiry-Relationship Approach）和基本数据模型（结构数据模型）。*主要考点在怎么将 ER 图转换为基本数据模型*。

#### 概念数据模型

概念数据模型是按照用户的观点来对数据和信息建模，主要用于数据库设计。是从用户的角度进行建模的，是现实世界到信息世界的一个抽象。用 ER 图来描述概念数据模型，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。

在 ER 模型中，使用椭圆表示属性（其实就是对某个实体的一个说明，一般没有），长方形表示实体（强实体），长方形里两道竖线表示弱实体 (以来于强实体)，菱形表示联系，联系的两端要填写联系类型，如图所示

![](../../004.jpeg)

- 实体：客观存在并可相互区别的事物，比如人、超市等
- 弱实体和强实体：弱依赖于强存在而存在
- 实体集：具有相同类型和共享相同属性的实体集合，如学生、课程
- 属性：实体具有的属性。属性分类：简单属性和复合属性；单值属性和多值属性；NULL 属性；派生属性。比如人的名字，性别等等
- 域：属性的取值范围
- 码（key）：唯一标识实体的属集，也就是主键
- 联系：现实世界中事物内部及事物之间的联系。ER 图中反映为实体内部的联系和实体之间的联系
- 联系类型：一对一，一对多，多对多（`M:N`）


#### 基本数据模型

是按照计算机系统的观点来对数据和信息建模，主要用于 DBMS 的实现，也就是数据库系统设计。这是数据库系统的核心和基础。常用的基本数据模型有层次模型、网状模型、关系模型和面向对象模型。

![](../../005.jpeg)

左边就是 ER 图，右边就是基本数据模型

- 关系模型：就是一张一张独立的表，也就是使用二维表的形式表示的实体-联系模型
- 网状模型：就是表示了很多表之间的联系
- 面向对象模型：就是表和对象之间的一个映射，以对象为单位，对象中包含属性和方法，具有类和继承等特点。


#### 基本数据模型要素

数据结构（静态），数据操作（动态），数据的约束条件

重点关注约束条件：
- 实体的完整性。实体完整性是指实体店主属性不能为空值。也就是主键不能为空。
- 参照完整性。比如外键不能匹配不到值。比如有一张交易表，其中的状态有相关的状态码，而状态码具体的信息单独存在于自己的表中，那么对于交易表中的状态字段要么为空，要么是状态表中的值。如图所示
![](../../006.jpeg)

- 用户定义完整性：比如一个人的年龄不能超过 200

#### 关系模型要素

关系模型中数据的逻辑结构是一张二维表（行列组成）。其优点是建立在严格的数学概念基础上。概念单一、结构简单、清晰，用户易懂易用。存取路径对用户透明，从而数据独立性、安全性好，简化数据库开发工作。缺点就是由于存取路径透明，查询效率往往不如非关系数据模型。

几个概念：
- 关系：可以理解为一张表，每个关系都具有一个关系名，也就是表名
- 元组：表中的一行
- 属性：表中的一列
- 域：字段的取值限制
- 关键字：主键
- 关系模式：对关系的描述。格式为：关系名（属性 1，属性 2...），在数据库中称为表结构


## 关系代数

![](../../007.jpeg)

并集和交集就不说了，差集：`S1-S2` 这里表示 `S1` 中有而 `S2` 中没有的。笛卡尔积其实就是不做关联，直接组合
![](../../008.jpeg)

![](../../009.jpeg)

下面举例说明

![](../../010.jpeg)


![](../../011.jpeg)

![](../../012.jpeg)

两道考试真题

![](../../013.jpeg)

这里第二道题好理解，注意查询的时候是直接对两张表进行查询，没有做关联，所以条件中需要将关联条件加上。

第一道题中首先要注意选项中的数字表示的是列，比如 `R，S` 自然连接后的列是 `A,B,C,D,E`，其实也就是 `1，2，3，4，5`。而选项中使用的是 `R×S` 表示的是笛卡尔积，最终的列是 `A,B,C,D,C,D,E` ，一般如果属性名相同需要重命名，用序号表示就是 `1，2，3，4，5，6，7`。注意：没有引号。首先是需要选择 `R.B>S.E` 的行，所以需要先将重复属性去除，于是只取 $\pi_{1,2,3,4,7}$，也就是将多余的 CD 列去掉。而 $\sigma_{R.B>S.E}$ 也就是等价于 $\sigma_{2>7}$。而我们需要针对笛卡尔积转换为自然连接（`3=5，4=6`）, 下尖括号表示且。

## 函数依赖及范式

### 函数依赖

- 完全函数依赖：给定一个 X，能唯一确定一个 Y，$Y=X*X$，就称 X 确定 Y，或者说 Y 依赖于 X，记坐 $X->Y$。`(Sno, Cno)-> Grade` 是完全函数依赖
- 部分函数依赖：A 可以确定 C，（A，B）可以确定 C，表示（A，B）中的一部分（即 A）可以确定 C，称为部分函数依赖。`(Sno, Cno)->Sdept` 是部分函数依赖。
- 传递函数依赖：当 A 和 B 不等价时，A 可以确定 B，B 可以确定 C，则 A 可以确定 C，时传递函数依赖；若 A 和 B 等价，则不存在传递，直接就可以确定 C。`Sno->Sdept, Sdept->Mname`，则称 Sno 传递依赖于 Mname。

Armstrong 公理：从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则，这些规则常被称作 Armsgrong 公理。

设关系式 $R(U,F)$，U 是关系模式 R 的属性集，F 是 U 上一组函数依赖，则有一下三条推理规则（其实可以理解 R 就是表，U 就是字段，F 就是一组关系集合）：
- `A1` 自反律：若 $Y\subseteq X\subseteq U$，则 $X->Y$ 为 F 所包含
- `A2` 增广律：若 $X->Y$ 为 F 所包含，且 $Z\subseteq U$，则 $XZ->YZ$ 为 F 所包含
- `A3` 传递律：若 $X->Y, Y->Z$ 为 F 所包含，则 $X->Z$ 为 F 所包含

根据上面三条推理规则，又可退出下面三条推理规则：
- 合并规则：若 $X->Y, X->Z$，则 $X->YZ$ 为 F 所包含
- 伪传递规则：若 $X->Y, WY->Z$，则 $XW->Z$ 为 F 所包含
- 分解规则：若 $X->Y, Z\subseteq Y$，则 $X->Z$ 为 F 所包含


一些概念：
- 超键：能唯一标识表的属性的组合，其实就是主键或者唯一索引，当然了，有时候其中可能存在多余的属性，就算去掉也可以唯一标识
- 主键：或者叫码。
- 候选键：去掉超键中冗余的属性，剩下的属性就是候选键。候选键就是不能再去掉相关属性了，否则就不是键了
- 外键：略
- 主属性与非主属性：候选键内的属性为主属性，其他属性为非主属性
- 候选码：能够唯一标识一条记录的最小属性集，类似候选键
- 全码（`All-key`）：所有属性组组成该关系模式的候选码，称为全码。

### 范式

其实就是几种规范，有第一范式，第二范式，第三范式，BC 范式，第四范式，第五范式。

#### 第一范式 1NF

其实就是不能有合并行，或者合并列。
![](../../014.jpeg)

如图所示，确定也比较明显，出现这种情况时可以通过分表来解决，比如增加子表。

#### 第二范式 2NF

**如果关系 R 属于 1NF**，且每个非主属性完全函数依赖于任何一个候选码（主键），则 R 属于 2NF。

![](../../015.jpeg)

比如这里学号时主键，但是并不能完全确定课程号和成绩。可以将表进行分解。其实就是消除部分依赖。

#### 第三范式 3NF

**在满足 1NF 基础上，表中不存在非主属性对码的传递依赖**。前面范式都是针对非主属性的相关依赖关系进行处理。

如上面例子，学生关系模式就不满足 3NF，因为学生无法直接决定系主任和系名，是由学号->系编号, 再由系编号->系主任，系编号->系名，因此存在非主属性对主属性对传递依赖。

其实就是消除传递依赖。

#### BC 范式 BCNF

是指在 3NF 基础上进一步消除主属性对于吗的部分函数依赖和传递依赖。在BC范式中，每个属性都必须完全依赖于主键，而不能依赖于主键的一部分。这意味着如果一个属性依赖于主键的一部分，那么该属性必须被拆分成多个表，以消除多值依赖。

可以简单理解为某个非主属性可以决定主属性

举例说明

比如我们有一个学生导师表，其中包含字段：学生 ID，专业，导师，专业 GPA，这其中学生 ID 和专业是联合主键。

| StudentId | Major | Advisor	 | MajGPA |
| ---- | ---- | ---- | ---- |
| 1 | 人工智能 | Edward | 4.0 |
| 2 | 大数据 | William | 3.8 |
| 1 | 大数据 | William | 3.7 |
| 3 | 大数据 | Joseph | 4.0 |

这个表的设计满足三范式，有主键，不存在主键的部分依赖，不存在非主键的传递依赖。但是这里存在另一个依赖关系，“专业”函数依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。

所以这个表的部分主键依赖于非主键部分，那么我们可以进行以下的调整，拆分成2个表：

学生导师表：

|StudentId|	Advisor|	MajGPA|
|-|-|-|
|1	|Edward	|4.0|
|2|	William|	3.8|
|1|	William	|3.7|
|3|	Joseph	|4.0|

导师表：

|Advisor|	Major|
|-|-|
|Edward	|人工智能|
|William|	大数据|
|Joseph	|大数据|

在看一个例子
![](../../016.jpeg)

这里解释下，首先为什么只有两种情况的组合键，一般如果某个属性都是决定别的属性，而没有别的属性能决定它，那么一般来说这个属性一定是主属性。通俗来讲，就是每一个依赖的左边决定因素都必然包含于候选键中。

如果候选键是 `(S,T)`，而 T->J，那满足；如果候选键是 `(S,J)`，此时存在 T->J，相当于非主属性能决定主属性了，就不满足了。

看真题

![](../../017.jpeg)

这里先看没有出现在右边的由 AD，但是 AD 无法推导出所有属性，可以加 B 或者 C，所以先选择 C。现在候选键有 ACD 和 ABD，包含了所有属性，所以下面选择 A。

![](../../018.jpeg)

这里是这样的，看达到什么范式，*先找候选码*。首先第一范式肯定是满足了，而候选码可以推导为 EM，而存在 E->N, M->L 这种是部分依赖，不满足 2NF
