```toc
```

参考：
《算法设计-康奈尔大学》
[经典算法问题——稳定匹配](https://zhuanlan.zhihu.com/p/225925804)

## 1. 问题描述

给出一个 ` n` 个男性的集合 `M` 和 `n` 个女性的集合 `W`，其中：

-   每位男性根据对所有女性的心仪程度从高至低进行排名；
-   每位女性根据对所有男性的心仪程度从高至低进行排名。

根据以上条件，我们需要找到一个“稳定匹配”。

### 1.1 匹配

匹配 `S` 是一个包含有序数对 `m−w` 的集合，其中 $m∈M$ 且 $w∈W$ ，其中：

-   每个男性最多出现在一个数对中；
-   每个女性最多出现在一个数对中。

### 1.2 完全匹配

如果 `|S|=|M|=|W|=n` ，则匹配 `S` 是完美匹配，也就是说，男女数量相等且都有唯一匹配的对象。

### 1.3 不稳定因素

给出一个完美匹配 `S` ，如果其中存在一个男性 `m` 和一个女性 `w` 同时满足下列条件：

-   `m−w` 不在匹配 `S` 中；
-   `m` 比起他当前配偶，更喜欢 `w` ;
-   `w ` 比起她当前配偶，更喜欢 ` m ` 。

则称男性 `m` 和女性 `w` 是不稳定的，也就是说， `(m, w)` 是**不稳定因素**。这里举例说明：
例 1: 假设有两个男人集合 `{m1, m2}`  和两个女人集合 `{w1, w2}`，优先表如下
```
m1 更偏爱 w1 而不爱 w2
m2 更偏爱 w1 而不爱 w2
w1 更偏爱 m1 而不爱 m2
w2 更偏爱 m1 而不爱 m2
```
那么这里存在一个由 `(m1, w1) , (m2, w2)` 对组成的唯一稳定匹配。而另外一组由 `(m1, w2) , (m2, w1)` 组成的完全匹配不是稳定匹配，因为 `(m1, w1)` 对构成了一个不稳定因素。

例 2: 假设上面例子中的优先表如下
```
m1 更偏爱 w1 而不爱 w2
m2 更偏爱 w2 而不爱 w1
w1 更偏爱 m2 而不爱 m1
w2 更偏爱 m1 而不爱 m2
```
那这里就存在由 `(m1, w1) , (m2, w2)` 对组成的匹配是稳定匹配，因为两个男人已经是最满意了，因此没人想要离开他们目前匹配的伴侣。而由 `(m2, w1) , (m1, w2)` 对组成的匹配也是稳定的，因为两个女人已经是最满意的了，也不会离开现有伴侣。

### 1.4 稳定匹配

一个不存在 不稳定因素 的完美匹配。

### 1.5 Gale-Shapley 算法

```
初始所有的 m∈M 和 w∈W 都是自由的，即 S 是空集合
while 存在男人 m 是自由的且还没对每个女人求过婚
	选择这样一个男人 m
	令 w 是 m 的优先表中 m 还没有求过婚的最高排名的女人
	if w 是自由的 then
		(m,w) 变成约会状态
	else w 当前与 m1 约会
		if w 更偏爱 m1 而不爱 m then
			 m 保持自由
		else w 更偏爱 m 而不爱 m1
			(m,w) 变成约会状态
			m1 变成自由状态
		endif
	endif
end while
return 稳定匹配 S
```

简单来说，算法的策略如下：

-   男性策略：单身的男性会主动出击，根据喜好降序向所有女性求婚，直到有配偶为止；
-   女性策略：被动等待男性求婚，如果女性仍处于单身，则直接接受；有配偶的情况下被更心仪的男性求婚，则会抛弃原来的，接受更好的。


**有穷性：算法最多在** $n^2$ **次 `while` 迭代后一定会结束。**

**证明**

`while` 循环中每次男性向一位女性求婚，最多只有 $n^2$ 次求婚。

**完美性：算法中所有男性和女性都匹配完毕。**

**证明（反证法）**

1.  假设：存在男性 $m$ 在算法终止后仍然未匹配到女性
2.  由此可知，一定有一位女性 $w$，也没有匹配到男性
3.  根据算法，一位单身女性一定会同意向她求婚的男性，所以女性 $w$ 一定没有被求过婚
4.  根据算法 `while` 循环条件，因为男性 $m$ 没有配偶，因此他一定会向所有女性求过婚算法才会终止
5.  因此男性 $m$ 向女性 $w$ 求过婚
6.  3 与 5 产生矛盾，假设不成立，证明完毕

**稳定性：算法产生的匹配中，不会有不稳定因素**

**证明**

1.  假设：`GS` 匹配 $S^∗$ 不包含配对 `m-w`（`m` 是一位男性，`w` 是一位女性）
2.  情况 1：`m` 从未向 `w` 求婚
* 1.  因为 `m` 是降序求婚，所以比起  `w`，`m` 更喜欢 `GS` 算法得到的配偶
* 2.  所以 `(m, w)` 不是不稳定因素

3.  情况 2：`m` 向 `w` 求过婚
* 1.  所以 `w` 拒绝了或抛弃了 `m`
* 2.  所以 `w` 更喜欢 `GS` 算法得到的配偶
* 3.  所以 `(m, w)` 不是不稳定因素

4.  根据上文“不稳定因素”的定义，`GS` 匹配不会产生不稳定因素，因此是稳定的

**正当配偶**

定义：如果存在一个稳定匹配中男性 $m$ 和女性 $w$ 匹配在一起，则称女性 $w$ 是男性 $m$ 的正当配偶。

**男性最佳分配**

`GS` 算法中每个男性都能分配到最佳的正当配偶，所以 `GS` 算法得到的分配一定是男性最佳分配。这里先定义下"最佳分配"，如果存在一个稳定匹配包含了 $(m,w)$ 对，我们就说女人 $w$ 是男人 $m$ 的有效伴侣。如果 $w$ 是 $m$ 的有效伴侣，且在 $m$ 对女性的优先级排名中，没有比 $w$ 更高的女人是他的有效伴侣，那么 $w$ 就是 $m$ 的最佳有效伴侣，或者叫此男性的最佳分配。

**证明**

1.  假设：在 `GS` 算法得到的匹配 `S` 中，存在一位男性与一位女性匹配，该女性不是最佳正当配偶
2. 因为男性根据喜好降序求婚
-   所以有男性在 `GS` 算法中被最佳正当配偶拒绝
3. 令男性 `m1` 是第一个这样的男性，同时令女性 `w1` 是第一个拒绝他的正当配偶（也就最佳正当配偶）
4. 因此一定存在 `S'` 是一个包含 `m1-w1` 的稳定匹配，因为 `w1` 是 `m1` 的有效伴侣。
5. 不妨令在 `GS` 算法得到的稳定匹配 `S` 中，当男性 `m1` 被女性 `w1` 拒绝时，女性 `w1` 与男性 `m2` 配对
6. 所以，女性 `w1` 比起男性 `m1` 更喜欢男性 `m2`
7. 不妨假设在 `S'` 中，女性 `w2` 是男性 `m2` 的配偶
8. `GS` 算法中，男性 `m2` 在男性 `m1` 被女性 `w1` 拒绝的时候，还没有被任何正当配偶拒绝（因为我们令男性 `m1` 和女性 `w1` 是**第一对**这样的男女）
9. 根据 5 和 7 的结论，`m2-w1` 和 `m2-w2` 都是正当配偶，现在已知在 `S` 中男性 `m2` 与女性 `w1` 配对
10. 如果男性 `m2` 在向女性 `w1` 求婚时，如果已经向女性 `w2` 求过婚，一定被拒绝了，与 8 矛盾
11. 因此，当男性 `m2` 向女性 `w1` 求婚时，他还没有向女性 `w2` 求过婚
12. 所以，男性 `m2` 比起女性 `w2` 更喜欢女性 `w1`
13. 根据 6 和 12 的结论，`(m2, w1)` 是 `S'` 中的不稳定因素，因此 `S'` 不是稳定匹配，这与 4 的结论矛盾

因此假设不成立，说明 `GS` 算法中所有男性的配偶该都是最佳正当配偶，`GS` 算法是男性最佳策略

**女性最劣分配**

GS 算法中女性一定分配到的是最差的正当配偶。

**证明**

1.  假设： `Z-A` 在 `GS` 算法得到的稳定匹配 `S` 中匹配，但是男性 `Z` 不是女性 `A` 的最差正当配偶
2.  那么，存在稳定匹配 `S'`，其中女性 `A` 与男性 `Y` 配对，且男性 `Y` 是更差的正当配偶
3.  所以女性 `A` 比起男性 `Y` 更喜欢男性 `Z`
4.  在 `S'` 中，令女性 `B` 是男性 `Z` 的配偶，根据 `GS` 算法的男性最优性，女性 `A` 是男性 `Z` 的最佳正当配偶
5.  所以男性 `Z` 比起女性 `B` 更喜欢女性 `A`
6.  因此根据 3 和 5，`(Z, A)` 是 `S'` 中的不稳定因素，所以 `S'` 并不是稳定匹配，与 2 矛盾
7.  因此假设不成立，说明所有女性分配到的男性都是最差正当配偶，`GS` 算法是女性最劣分配。

基本实现代码
```java
package datastructure;  
  
import java.util.ArrayList;  
import java.util.Arrays;  
import java.util.LinkedList;  
import java.util.List;  
import java.util.Objects;  
import java.util.Queue;  
import java.util.stream.Collectors;  
  
/**  
 * G-S算法  
 *  
 * @date 2022/11/14  
 **/public class GS {  
  
    /**  
     * G-S     
     * @param manPriorities 索引代表男性编号，数组代表最喜好女性优先级，  
     *                     如 [[0,1,2],[1,0,2],[0,1,2]] 优先级从高到低  
     * @param womanPriority 索引代表女性编号，数组代表最喜好男性优先级，  
     *                      如 [[1,2,0],[0,1,2],[0,1,2]]  
     * @return 稳定匹配, 如 {{0,1},{1,2},{2,0}}  
     */    
     private static List<List<Integer>> solution(
     int[][] manPriorities, int[][] womanPriority) {  
        List<List<Integer>> resultS = new ArrayList<>();  
        int n = manPriorities.length;  
        // 女人对男人的优先级与索引取反，
        // 因为后面我们需要根据索引来找到男人的优先级  
        List<int[]> wpReverse = new ArrayList<>();  
        for (int[] wp : womanPriority) {  
            // 女人对男人的优先级数组，数组索引代表优先级高低，值代表男人  
            // 索引代表男人，值代表优先级，值越小优先级越高  
            int[] wpR = new int[n];  
            for (int j = 0; j < n; j++) {  
                wpR[wp[j]] = j;  
            }  
            wpReverse.add(wpR);  
        }  
        // 自由状态下的男人  
        Queue<Integer> freeMen = new LinkedList<>();  
        for (int i = 0; i < n; i++) {  
            freeMen.offer(i);  
        }        
        // 男人匹配女人的索引（按照其优先级）,都是从0开始  
        int[] manIdx = new int[n];  
        Arrays.fill(manIdx, 0);  
  
        // 女人的丈夫，如果为-1表明还没有丈夫  
        int[] wHusband = new int[n];  
        Arrays.fill(wHusband, -1);  
  
        // 如果不为空，则一直循环  
        while (!freeMen.isEmpty()) {  
            // 取出一个男人，这里暂不移出队列  
            int m = freeMen.peek();  
            // 从该男人对女人的优先级列表中取出下一个需要求婚的女性  
            int w = manPriorities[m][manIdx[m]];  
            manIdx[m]++;  
  
            // 女方没有配偶  
            if (wHusband[w] == -1) {  
                resultS.add(Arrays.asList(m, w));  
                freeMen.poll();  
                wHusband[w] = m;  
            } else if (wpReverse.get(w)[wHusband[w]] > wpReverse.get(w)[m]) {  
                // 女人w有配偶,但是男人m比当前配偶更有吸引力(值越小优先级越高)  
                int i;  
                // 找到女人之前在S中的对  
                for (i = 0; i < n; i++) {  
                    if (Objects.equals(resultS.get(i).get(1), w)) {  
                        break;  
                    }  
                }  
                // 女人的原老公  
                Integer oldHusband = resultS.get(i).get(0);  
                // 移出原m-w对  
                resultS.remove(i);  
                // 添加新的m-w对  
                resultS.add(Arrays.asList(m, w));  
                // 队列移出现老公  
                freeMen.poll();  
                // 队列添加原老公  
                freeMen.offer(oldHusband);  
                wHusband[w] = m;  
            } else {  
                // w 拒绝了 m            
            }  
        }  
        return resultS;  
    }  
  
    public static void main(String[] args) {  
        int[] m1 = new int[]{0, 1, 2};  
        int[] m2 = new int[]{1, 0, 2};  
        int[] m3 = new int[]{0, 1, 2};  
        int[][] manPriorities = new int[][]{m1, m2, m3};  
  
        int[] w1 = new int[]{1, 2, 0};  
        int[] w2 = new int[]{0, 1, 2};  
        int[] w3 = new int[]{0, 1, 2};  
        int[][] womanPriority = new int[][]{w1, w2, w3};  
  
        List<List<Integer>> resultS = solution(manPriorities, womanPriority);  
        resultS.forEach(  
            e -> System.out.println(  
                e.stream().map(String::valueOf).collect(Collectors.joining(",")))  
        );  
    }  
}

// 输出
0,1
1,0
2,2
```



## 2. 五个典型问题

在展开讨论之前先介绍一下后面会用到的表达方式，这里借用图的概念，由于其强大的表达能力，后面将会不断出现。

把图 $G$ 看作一组个体之间二元关系的一种编码方式。其由一对集合 $(V, E)$ - 结点集合 $V$ 和边的集合 $E$ 构成，每条边与两个节点"相交"。于是我们把一条边 $e\in E$ 表示成 $V$ 的两个元素的子集： $e=\{u, v\}, u, v\in V$，其中称 $u$ 和 $v$ 为 $e$ 的端点。

### 2.1 区间调度-贪心算法

假设有某种资源，可能是一个会议室，很多人都需要在某个时间段使用这个资源。一个需求采用这种形式：是否能从时刻 $s$ 开始直到时刻 $f$ 预定这个资源吗？我们假设每个时刻最多一个人使用这个资源，一个调度员想接受这些需求的一个子集，而拒绝所有其他需求，使得被接受的需求时间上不重叠。目标就是使得被接受的需求数目最大。

更数学化的说法就是，有标记为 $1, 2,..., n$ 的 $n$ 个需求，每个需求 $i$ 由开始时间 $s_i$ 和结束时间 $f_i$ 指定。当然，对所有的 $i$，我们有 $s_i < f_i$ 。如果两个需求 $i$ 和 $j$ 所要求的区间不是重叠的，这就是说，需求 $i$ 比需求 $j$ 处在一个更早的时间区间 ($f_i \leq s_j$)，或者需求 $i$ 比需求 $j$ 处在一个更迟到时间区间 ($f_j \leq s_i$)，那么它们是相容的。更一般的说，如果每对需求 $i, j \in A, i \neq j$，都是相容的，那么需求的子集 $A$ 是相容的。目标就是选择一个更大的相容的需求子集。

下图给出了一个实例。注意只存在一个大小为 4 的相容集合，并且就是最大的相容集合

![[img/稳定匹配001.png]]

我们马上可以看到这个问题可以用一个非常自然的算法求解，这个算法按照某种启发式的方法把一组需求排序，然后"贪心"地对需求进行一轮处理，选出最大的相容子集。这是一类典型的贪心算法。


### 2.2 带权的区间调度-动态规划算法

在区间调度问题中我们的目标是使得同时考虑的需求数目达到最大。现在，更一般地假设每个需求区间 i 有一个相联系的值或者权 $v_i > 0$ ；我们可以把它描述为：如果对第 i 个人的需求做出安排，我们从他那里挣到的钱数。我们的目标将是找到一个总价值最大的相同区间子集。

对每个 $i, v_i = 1$ 的情况只不过是基本的区间调度问题；但是任意值的出现使得这个极大化问题的本性有了一些改变。例如，考虑如果 $v_1$ 超过所有其他的 $v_i$ 之和，那么最优解一定包含区间 1，而不管整个区间集的结构。此时就不能使用贪心算法了，而是使用动态规划算法处理。


### 2.3 二分匹配-网络流



### 2.4 独立集-NP 完全性



### 2.5 竞争的便利店选址问题-PSPACE 完全性