```toc
```
本章首先阐明两个基本的方法来证明一个贪心算法对问题提供一个最优解。第一个方法可以看作是建立*贪心算法领先* 的概念。这里的含义是如果一个人以一步接一步的方式测量贪心算法的进展时，他会看到在每一步做得都比其他的算法好。从而证明产生了一个最优解。第二个方法被称为*交换论证*，它是更一般化：考虑对这个问题的任何可能的解，逐渐把它转换成由贪心算法找到的解且不损害它的质量。从而也证明了贪心法一定能找到一个至少与任何其他解一样好的解。

后续将专注于贪心算法的几个最著名的应用：图中的最短路径，最小生成树问题，以及为实现数据压缩构造 Huffman 码。最后要有一个更复杂的应用，最小费用有向树问题，它将把什么事贪心算法的概念进一步推广。

## 1. 区间调度-贪心算法领先

回顾一下区间调度问题，有一组需求 $\{1,2,\dots,n\}$，第 $i$ 个需求与一个始于 $s(i)$ 且止于 $f(i)$ 的时间区间相对应。如果没有两个需求在时间上重叠，就说需求的子集是相容的，我们的目标是找到一个最大的相容子集，也叫最优子集。

区间调度的贪心算法中国呢的基本思想就是使用一个简单的规则来选择第一个需求 $i_1$，一旦一个需求 $i_1$ 被接受，那么拒绝所有与 $i_1$ 不相容的需求，然后选择下一个被接受的需求 $i_2$，并且再次拒绝所有与 $i_2$ 不相容的需求，以此类推。这里最大的挑战是决定用哪个简单的规则来选择，这里有许多自然但给不出好的解释的规则。

* 最明显的规则可能总是选择最早开始的有效需求——即一个具有最小开始时间 $s(i)$ 的需求。按这种方式能尽早的开始使用我们的资源。这个方法不能得到最优解。如果最早需求 $i$ 是关于一个酣畅时间区间的，那么接受了需求 $i$，我们可能要拒绝一大批对于较短时间区间的需求。**我们的目标是满足尽可能多的需求**，我们将以一个不是最理想的解结束。



































