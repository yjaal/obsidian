```toc
```
本章首先阐明两个基本的方法来证明一个贪心算法对问题提供一个最优解。第一个方法可以看作是建立*贪心算法领先* 的概念。这里的含义是如果一个人以一步接一步的方式测量贪心算法的进展时，他会看到在每一步做得都比其他的算法好。从而证明产生了一个最优解。第二个方法被称为*交换论证*，它是更一般化：考虑对这个问题的任何可能的解，逐渐把它转换成由贪心算法找到的解且不损害它的质量。从而也证明了贪心法一定能找到一个至少与任何其他解一样好的解。

后续将专注于贪心算法的几个最著名的应用：图中的最短路径，最小生成树问题，以及为实现数据压缩构造 Huffman 码。最后要有一个更复杂的应用，最小费用有向树问题，它将把什么事贪心算法的概念进一步推广。

## 1. 区间调度-贪心算法领先

回顾一下区间调度问题，有一组需求 $\{1,2,\dots,n\}$，第 $i$ 个需求与一个始于 $s(i)$ 且止于 $f(i)$ 的时间区间相对应。如果没有两个需求在时间上重叠，就说需求的子集是相容的，我们的目标是找到一个最大的相容子集，也叫最优子集。

区间调度的贪心算法中国呢的基本思想就是使用一个简单的规则来选择第一个需求 $i_1$，一旦一个需求 $i_1$ 被接受，那么拒绝所有与 $i_1$ 不相容的需求，然后选择下一个被接受的需求 $i_2$，并且再次拒绝所有与 $i_2$ 不相容的需求，以此类推。这里最大的挑战是决定用哪个简单的规则来选择，这里有许多自然但给不出好的解释的规则。

* 最明显的规则可能总是选择最早开始的有效需求——即一个具有最小开始时间 $s(i)$ 的需求。按这种方式能尽早的开始使用我们的资源。这个方法不能得到最优解。如果最早需求 $i$ 是关于一个酣畅时间区间的，那么接受了需求 $i$，我们可能要拒绝一大批对于较短时间区间的需求。**我们的目标是满足尽可能多的需求**，我们将以一个不是最理想的解结束。在真的坏的情况——比如说，当结束时间 $f(i)$ 是所有需求中最大的——所接受的需求 $i$ 将使我们的资源这个那个时间都被它占用。在这种情况下我们的贪心法只接受一个需求，而最优解可能接受许多需求，如图 (a)。

* 这可能建议我们应该从接受最小时间区间的需求开始——即 $f(i)-s(i)$ 尽可能小的需求。结果是，某种情况下这是比前一个规则好一点的规则，但是它仍旧可能产生一个不是最理想的调度。如图 (b)，在中间接受一个最短的区间将阻止我们接受其他构成最优解的两个区间。

* 在前一个贪心规则中，我们的问题是第二个需求与第一和第三个需求都竞争——即接受这个需求使得我们拒绝了其他两个的需求。我们可以基于下面的思想来设计一个贪心算法：对每个需求，我们计算其他不相容的需求个数，并且接受有着最少不相容个数的需求。这个贪心选择在前一个例子将得到最优解。为这个规则找一个坏的例子有难度，但是是可以做到的，如图 (c)。

![[贪心算法001.png]]

一个导致最优解的贪心规则是基于第四个思想：**接受最早结束的需求**，即 $f(i)$ 尽可能的小的需求 $i$ 为第一个需求。这是一个比较自然的想法：当能够满足一个需求时，保证资源尽可能早地被释放。

举例说明，使用 $R$ 表示既没有接受也没有拒绝的需求的集合，用 $A$ 表示被接受的需求集合。如下图

![[贪心算法002.png]]

基本算法如下
>初始令 $R$ 是所有需求的集合，设 $A$ 为空
>while $R$ 不为空
>	选择一个有最小结束时间的需求 $i \in R$
>	把 $i$ 加到 $A$ 中
>	从 $R$ 中删除与需求 $i$ 不相容的所有需求
>end while
>返回集合 $A$ 作为被接受的需求集合

*命题*
> $A$ 是一个相容的需求集。

$A$ 是一个相容的需求集显而易见，终点在于需要证明这是一个最优解。为了便于比较，令 $O$ 是一个最优解的区间集合，理想的是证明 $A=O$，但是这太难了，我们可以证明：可能存在许多最优解，$A$ 是其中一个，即 $|A|=|O|$，即 $A$ 和 $O$ 包含同样的区间个数，也是其中一个最优解。

这里证明的主要思想就是：贪心法"领先"于这个解 $O$。也就是贪心法计算的每一步都"领先"于 $O$。设 $i_1, i_2,\dots,i_k$ 是 $A$ 中的需求，并按照其加入到 $A$ 到次序排列。$|A|=k$。设 $O$ 中的需求是 $j_1, j_2,\dots,j_m$，于是证明目标就是证明 $k=m$。

上面的贪心法保证了 $f (i_1)\leq f(j_1)$，这就是说贪心法第一步"领先"了。那后面的每一步是不是都"领先"呢？

*命题*
>对所有的指标 $r\leq k$，有 $f (i_r)\leq f(j_r)$。

这里采用归纳法进行证明。
对于 $r=1$，有 $f (i_1)\leq f(j_1)$。
假设 $r-1$ 时，有 $f (i_{r-1})\leq f(j_{r-1})$。注意：$f$ 表示起始时间，$s$ 表示结束时间。于是 $f (i_{r-1})\leq f (j_{r-1}) < s(j_{r-1}) \leq f(j_{r})$。这就说明，当贪心法计算到任务 $i_{r-1}$ 时，是可以选择任务 $j_r$ 的，因为是相容的。所以就有 $f (i_r)\leq f(j_r)$。

*定理*
>贪心法返回一个最优的集合 $A$

这其实很好证明了，通过上面命题的证明，我们证明了贪心法每一步都“领先” $O$，如果 $O$ 中有比 $A$ 多的需求，那么 $A$ 是一定可以选择进来的。

**运行时间**
首先可以使用算法以 $O(nlog_n)$ 时间对 $n$ 个需求进行排序，然后每次选择第一个区间，于是使用 $O(n)$ 对时间构造一个数组 $S[1,2,\dots,n]$。


### 1.1 相关问题：调度所有的区间

上面的区间调度处理的问题是在一个给定的时间区间内，尽可能多的接受任务，也就是找到一个任务的最大相容子集。而考虑这样一个问题，任务是固定的，我们想使用尽可能少的资源满足所有的需求。如图所示，下面的任务使用三个资源就可以将所有任务安排。

![[贪心算法003.png]]

如图所示，需求被分成了三行，每行代表一个资源，每行中的需求都是相容的。有没有可能只只用两个资源就能满足呢？这是不可能的，因为 $a,b,c$ 三个任务是不相容的，所以至少需要三个资源。

我们定义一个区间集合的**深度**是通过时间线上任何一点的最大区间数。

*命题*
>在任何区间划分的实例中，资源数必须至少是区间集合的深度。


**设计算法**

设 $d$ 是区间集合的深度，对每个区间分配一个标签，其中标签取自数集 $\{1,2,\dots,d\}$，并且有如下性质：重叠的区间必须使用不同的数作为标签。这其实就已经给出了所需要的解，因为完全可以将标签翻译成资源的名字。

*算法*
>对所有的任务区间，根据开始时间进行排序
>设 $I_1, I_2,\dots,I_n$ 表示排序后的任务区间
>for $j = 1, 2, \dots, n$
>	取一个任务 $I_j$，设其起初的标签集都是 $S_i=\{1,2,\dots,d\}$
>	for $i=1, 2,\dots,j-1$ 的任务 $I_i$
>		将所有与 $I_j$ 重叠的 $I_i$ 的标签都从 $S_i$ 中移除
>	end for
>	if $S_i$ 不为空
>		分配一个标签给 $I_j$
>	else
>		暂时不给 $I_j$ 分配标签 (如果 $d$ 足够，不会出现此种情况)
>	end if
>end for

这里其实一开始如果不清楚 $d$ 的取值，可以在程序执行过程中进行递增，然后补充到标签集合中。

*命题*
>如果我们使用上述贪心算法，每个区间将被分配一个标签，且没有两个重叠的区间接受同样的标签。

*定理*
>上述贪心算法使用与区间集合深度等量的资源为每个区间安排一个资源，这是所需资源的最优数量。


## 2. 最小延迟调度：一个交换论证

考虑下面情况，我们有单一资源和一组使用资源的 $n$ 个需求，每个需求需要在一个时间区间。假设资源在时刻 $s$ 开始有效。但是与前面的问题相反，每个需求 $i$ 现在更加灵活，不是开始时间和结束时间的限制，而是需求 $i$ 有一个截止时间 $d_i$，并且要求一个长为 $t_i$ 的连续时间区间，希望被安排在截止时间之前的任何时刻。每个被接受的需求必须被分配一个长为 $t_i$ 的时间区间，且不同的需求被分配在不重叠的区间。**注意：目标是找到一个总延迟时间最小的调度**。

假设我们计划满足每个需求，但是允许让某些需求延迟启动，把每个需求的执行时间设为 $[s(i),f(i)]$，其中 $f(i)=s(i)+t_i$。如果需求 $i$ 错过了截止时间（即 $f(i)>d_i$），就表示需求延迟了。需求 $i$ 的延迟定义为 $l_i=f(i)-d_i$。，如果需求没有被延迟，那么 $l_i=0$。于是我们的目标就是用不重叠的区间安排所有的需求，使得最大的延迟 $L=max_il_i$ 达到最小。如下图就是一个最大延迟为 0 的例子

![[贪心算法004.png]]

**设计算法**

有几种自然的贪心方法，我们考虑任务的数据 $(t_i,d_i)$，并且按照某种简单的规则对它们排序
* 一种方法是把任务安长度 $t_i$ 增长的次序安排，使得短的任务尽快结束。这个方法完全忽略了任务的截止时间，可以通过一个坏的例子来证明不可行。如两个任务 $(1,100),(10,10)$。如果想达到延迟 $L$ 最小，那么第二个任务需要先开始。
* 在上面方法的建议下，我们可能考虑有效松弛时间 $d_i-t_i$ 非常小的任务——它们是哪种需要用最小延迟开始的任务。遗憾的是，这种方法也是不可行的。如有两个任务 $(1,2),(10,10)$，按照这种方法，第二个任务应该先开始执行，但是这显然无法使得 $L$ 最小。

其实，有一种方法是总能产生最优解的。那就是和最初的区间调度算法一样，按照结束时间 $d_i$ 增长次序排序，并且按照这个次序安排（即最早截止时间优先）。也就是 $d1\leq \dots \leq d_n$。任务 1 将在区间 $(s(1), f(1)=s(1)+t_1)$ 执行，任务 2 将在 $(s(2)=f(1),f(2)=s(2)+t_2)$ 区间执行，以此类推。

>按照截止时间进行排序，假定 $d1\leq \dots \leq d_n$
>初始， $f=s$
>按照这个次序考虑任务 $i=1, 2,\dots,n$
>	将任务 $i$ 安排在从 $s(i)=f$ 到 $f(i)=f+t_i$ 的时间区间
>	令 $f=f+t_i$
>end
>对 $i=1, 2,\dots,n$ 返回被安排的这组区间 $[s(i),f(i)]$

**分析**

首先算法产生的调度是没有"空隙"的，或者说没有空闲时间：存在任务要做，但是机器由于相关原因处于空闲状态。

*命题*
>存在一个没有空闲时间的最优调度






























