```toc

```


## 相关符号

|字符|描述|
|-|-|
| `\` |转义，如 `n` 可以匹配 `n`，而 `\n` 则匹配一个换行符|
| `^` |匹配开始位置|
| `$` |匹配结束位置，也就是结束为止必须是前面表达式匹配的样式|
| `*` |匹配前面的子表达式 0 次或多次，如 `zo*` 可以匹配 `z, zo, zoo`, 等价于 `{0,}` |
| `+` |匹配前面的子表达式 1 次或多次，如 `zo+` 可以匹配 `zo, zoo` |
| `?` |匹配前面子表达式 0 次或 1 次，等价于 `{0,1}` |
| `{n}` |n 是一个非负整数。匹配确定的 `n` 次，如 `o{2}` 只能匹配 `food` 中的两个 `o`，而不能匹配 `god` 中的一个 `o` |
| `{n,}` |表示至少匹配 `n` 次|
| `{n,m}` |n<=m, 表示至少匹配 `n` 次，最多匹配 `m` 次|
| `.` |匹配除 `\r`, `\n` 之外的任何单个字符|
| `(pattern)` |匹配 pattern 并获取这一匹配的子字符串，获取结果可以从产生的 `Matches` 集合中得到，如 "`industr(?:\|ies)`" 就比 "`industr\|industries`" 更简洁|
| `(?:pattern)` |匹配 `patter` 但是并不获取匹配的子字符串，也就是一个非获取匹配|
| `(?=pattern)` |正向肯定预查，在任何匹配 `pattern` 的字符串开始处匹配查找字符串。这是一个非获取匹配。例如“`Windows(?!95\|98\|NT\|2000)`”能匹配“`Windows3.1`”中的“`Windows`”，但不能匹配“`Windows2000`”中的“`Windows`”。|
| `(?<=pattern)` |反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“`(?<=95\|98\|NT\|2000)Windows`”能匹配“`2000Windows`”中的“`Windows`”，但不能匹配“`.1Windows`”中的“`Windows`”。|
| `(?<!pattern)` |反向否定预查，与正向否定预查类似，只是方向相反。例如“`(?<!95\|98\|NT\|2000)Windows`”能匹配“`3.1Windows`”中的“`Windows`”，但不能匹配“`2000Windows`”中的“`Windows`”。|
| `x\|y` |没有包围在 () 里，其范围是整个正则表达式。例如，“`z\|food`”能匹配“`z`”或“`food`”。“`(?:z\|f)ood`”则匹配“`zood`”或“`food`”。|
| `[xyz]` |字符集合。匹配所包含的任意一个字符。例如，“`[abc]`”可以匹配“`plain`”中的“`a`”。特殊字符仅有反斜线保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 – 如果出现在字符串中间表示字符范围描述；如果如果出现在首位（或末尾）则仅作为普通字符。右方括号应转义出现，也可以作为首位字符出现。|
| `[^xyz]` |排除型字符集合。匹配未列出的任意字符。例如，“`[^abc]`”可以匹配“`plain`”中的“`plain`”。|
| `[a-z]	` |字符范围。匹配指定范围内的任意字符。例如，“`[a-z]`”可以匹配“`a`”到“`z`”范围内的任意小写字母字符。|
| `[^a-z]` |排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“`[^a-z]`”可以匹配任何不在“`a`”到“`z`”范围内的任意字符。|
| `\b` |匹配一个单词边界，也就是指单词和空格间的位置。例如，“`erb`”可以匹配“`never`”中的“`er`”，但不能匹配“`verb`”中的“`er`”。|
| `\B` |匹配非单词边界。“`erB`”能匹配“`verb`”中的“`er`”，但不能匹配“`never`”中的“`er`”。|
| `\d` |匹配一个数字字符。等价于 `[0-9]`。注意 `Unicode` 正则表达式会匹配全角数字字符。|
| `\D` |匹配一个非数字字符。等价于 `[^0-9]`。|
| `\f` |匹配一个换页符。等价于 `x0c`。|
| `\n` |匹配一个换行符。|
| `\r` |匹配一个回车符。|
| `\s` |匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[fnrtv]`。注意 Unicode 正则表达式会匹配全角空格符。|
| `\S` |匹配任何非空白字符。等价于 `[^fnrtv]`。|
| `\t` |匹配一个制表符。|
| `\v` |匹配一个垂直制表符。|
| `\w` |匹配包括下划线的任何单词字符。等价于“`[A-Za-z0-9_]`”。注意 Unicode 正则表达式会匹配中文字符。|
| `\W` |匹配任何非单词字符。等价于“`[^A-Za-z0-9_]`”。|


## 贪婪与非贪婪模式

贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分 NFA 引擎所支持。

属于贪婪模式的量词，也叫做匹配优先量词，包括：

“{m, n}”、“{m,}”、“?”、“*”和“+”。

在一些使用 NFA 引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括：

“{m, n}?”、“{m,}?”、“??”、“*?”和“+?”。

从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，如“(Expression)+”；被忽略优先量词修饰的子表达式使用的就是非贪婪模式，如“(Expression)+?”。

**举例**
```python
# 贪婪匹配-匹配一个数字
def test4():
    content = 'Xiaoshuaib has 100 bananas'
    res = re.match('^Xi.*(\d+).*', content)
    # Xiaoshuaib has 100 bananas
    print(res.group(0))
    # 0，这里因为是贪婪匹配，所以在括号前面的表达式会尽量的匹配，于是匹配到了 Xiaoshuaib has 10
    # 所以这里group(1)就是 0
    print(res.group(1))

# 非贪婪匹配-匹配一个数字
def test5():
    content = 'Xiaoshuaib has 100 bananas'
    res = re.match('^Xi.*?(\d+).*', content)
    # Xiaoshuaib has 100 bananas
    print(res.group(0))
    # 100，这里是因为是非贪婪匹配，括号前面的表达式只匹配了 'Xiaoshuaib has '
    print(res.group(1))
```
`
